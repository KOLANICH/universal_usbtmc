#!/usr/bin/env python

"""
A shell for USBTMC devices
"""

import argparse
from builtins import input

from universal_usbtmc import UsbtmcReadTimeoutError

HOWTO = """
Enter a command. It will directly be sent to the USBTMC device.
If the command ends with a question mark ('?'), the answer
will be read from the device.
Quit the shell with  'quit'  or by pressing Ctrl-C
"""

def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--backend', '-b', #choices=('linux_kernel', 'python_usbtmc'),
        default='linux_kernel',
        help='The backend to use')
    parser.add_argument('device', help='')
    args = parser.parse_args()

    if args.backend == 'linux_kernel':
        from universal_usbtmc.backends.linux_kernel import Instrument
    elif args.backend == 'python_usbtmc':
        from universal_usbtmc.backends.python_usbtmc import Instrument
    elif args.backend == 'tcp_socket':
        from universal_usbtmc.backends.tcp_socket import Instrument
    else:
        parser.error('choose a valid backend')
    be = Instrument(args.device)
    print(HOWTO)
    print('> *IDN?')
    print(be.query("*IDN?"))
    try:
        while True:
            cmd = input('> ')
            cmd = cmd.strip()
            if cmd in ('quit', 'exit'):
                break
            try:
                if cmd.endswith('?'):
                    print(be.query(cmd))
                else:
                    be.write(cmd)
            except UsbtmcReadTimeoutError:
                print('Timeout occured')
    except KeyboardInterrupt as e:
        print('\nCtrl-C pressed.')
    except EOFError:
        pass
    print('Exiting...')

if __name__ == "__main__":
    main()

